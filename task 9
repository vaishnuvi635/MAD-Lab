Step 1: Firebase Project Setup
• Create a Firebase Project:
• Go to the HYPERLINK &quot;https://console.firebase.google.com/&quot;Firebase Console.
• Click &quot;Create a project&quot;, give it a name (e.g., flutter-notes-app), and click Continue.
• Disable Google Analytics for this project and click &quot;Create project&quot;.
• Install Firebase &amp; FlutterFire CLIs:
If you don&#39;t have them installed, open a terminal and run the following commands:
# Install the Firebase CLI
npm install -g firebase-tools
# Install the FlutterFire CLI
dart pub global activate flutterfire_cli
• Configure Your Flutter App:
• Create a new Flutter project: flutter create firestore_lab
• Navigate into the project directory: cd firestore_lab
• Log in to Firebase: firebase login

Run the configure command to connect your Flutter app to your Firebase project:
flutterfire configure

• The CLI will ask you to select the Firebase project you created. Choose it from the list. It
will automatically add the necessary plugins and generate the lib/firebase_options.dart
file.

Step 2: Add Dependencies &amp; Initialize Firebase
• Add Firestore Package:
• Open your pubspec.yaml file. The FlutterFire CLI should have already added
firebase_core. Now, add the cloud_firestore package.

dependencies:
flutter:
sdk: flutter
firebase_core: ^2.30.0 # Should be added by CLI
cloud_firestore: ^4.17.0 # Add this line
• Run flutter pub get in your terminal.
• Initialize Firebase in main.dart:
Modify your lib/main.dart file to initialize Firebase before the app runs.

Step 3: Implement the Firestore App Code
Code (lib/main.dart):
import &#39;package:flutter/material.dart&#39;;
import &#39;package:firebase_core/firebase_core.dart&#39;;
import &#39;package:cloud_firestore/cloud_firestore.dart&#39;;
import &#39;firebase_options.dart&#39;; // This file is generated by the FlutterFire CLI

// 1. Initialize Firebase before running the app.
void main() async {
WidgetsFlutterBinding.ensureInitialized();
await Firebase.initializeApp(
options: DefaultFirebaseOptions.currentPlatform,
);
runApp(const MyApp());
}
// 2. Data Model for our posts.
class Post {

final String? id;
final String title;
final String message;
final DateTime timestamp;

Post({
this.id,
required this.title,
required this.message,
DateTime? timestamp,
}) : timestamp = timestamp ?? DateTime.now();
// A factory constructor to create a Post from a Firestore document.
factory Post.fromFirestore(DocumentSnapshot doc) {
Map data = doc.data() as Map&lt;String, dynamic&gt;;
return Post(
id: doc.id,
title: data[&#39;title&#39;] ?? &#39;&#39;,
message: data[&#39;message&#39;] ?? &#39;&#39;,
timestamp: (data[&#39;timestamp&#39;] as Timestamp).toDate(),
);
}
}
// 3. Main Application Widget
class MyApp extends StatelessWidget {
const MyApp({super.key});

@override
Widget build(BuildContext context) {
return MaterialApp(
debugShowCheckedModeBanner: false,
title: &#39;Firebase Firestore Lab&#39;,
theme: ThemeData(primarySwatch: Colors.indigo, useMaterial3: true),
home: const FirestoreScreen(),
);
}
}
// 4. Main Screen with Firestore Integration
class FirestoreScreen extends StatefulWidget {
const FirestoreScreen({super.key});
@override
State&lt;FirestoreScreen&gt; createState() =&gt; _FirestoreScreenState();
}
class _FirestoreScreenState extends State&lt;FirestoreScreen&gt; {
final _titleController = TextEditingController();
final _messageController = TextEditingController();
final CollectionReference _postsCollection = FirebaseFirestore.instance.collection(&#39;posts&#39;);

// Method to add a new post to Firestore.
Future&lt;void&gt; _addPost() async {
if (_titleController.text.isNotEmpty &amp;&amp; _messageController.text.isNotEmpty) {
await _postsCollection.add({

&#39;title&#39;: _titleController.text,
&#39;message&#39;: _messageController.text,
&#39;timestamp&#39;: FieldValue.serverTimestamp(), // Use server time for consistency
});
_titleController.clear();
_messageController.clear();
FocusScope.of(context).unfocus();
}
}
@override
Widget build(BuildContext context) {
return Scaffold(
appBar: AppBar(title: const Text(&#39;Firestore Posts&#39;)),
body: Column(
children: [
_buildInputArea(),
const Divider(height: 1),
_buildPostsList(),
],
),
);
}

// UI for the input fields and button.
Widget _buildInputArea() {

return Padding(
padding: const EdgeInsets.all(16.0),
child: Column(
children: [
TextField(
controller: _titleController,
decoration: const InputDecoration(labelText: &#39;Title&#39;, border: OutlineInputBorder()),
),
const SizedBox(height: 10),
TextField(
controller: _messageController,
decoration: const InputDecoration(labelText: &#39;Message&#39;, border: OutlineInputBorder()),
),
const SizedBox(height: 10),
ElevatedButton(onPressed: _addPost, child: const Text(&#39;Add Post&#39;)),
],
),
);
}
// UI for displaying the list of posts in real-time.
Widget _buildPostsList() {
return Expanded(
child: StreamBuilder&lt;QuerySnapshot&gt;(
stream: _postsCollection.orderBy(&#39;timestamp&#39;, descending: true).snapshots(),
builder: (context, snapshot) {

if (snapshot.hasError) {
return Center(child: Text(&#39;Something went wrong: ${snapshot.error}&#39;));
}
if (snapshot.connectionState == ConnectionState.waiting) {
return const Center(child: CircularProgressIndicator());
}
if (snapshot.data!.docs.isEmpty) {
return const Center(child: Text(&#39;No posts yet. Add one!&#39;));
}
final posts = snapshot.data!.docs.map((doc) =&gt; Post.fromFirestore(doc)).toList();
return ListView.builder(
itemCount: posts.length,
itemBuilder: (context, index) {
final post = posts[index];
return ListTile(
title: Text(post.title, style: const TextStyle(fontWeight: FontWeight.bold)),
subtitle: Text(post.message),
);
},
);
},
),
);
}
}

Step 4: Configure Firestore and Security Rules
• Create Database:
• In the Firebase Console, go to Build &gt; Firestore Database.
• Click &quot;Create database&quot;.
• Select &quot;Start in test mode&quot;. This allows open access for the next 30 days. Click Next.
• Choose a location for your database (e.g., asia-south1) and click Enable.
• Update Security Rules:
• Go to the Rules tab in your Firestore Database.
• Replace the existing rules with the following to allow access for a limited time (e.g., until
the end of the year). This is safer than leaving it open indefinitely.

rules_version = &#39;2&#39;;
service cloud.firestore {
match /databases/{database}/documents {
match /{document=**} {
// Allow anyone to read and write until December 3, 2025
allow read, write: if request.time &lt; timestamp.date(2025, 12, 3);
}
}
}
• Click Publish.
